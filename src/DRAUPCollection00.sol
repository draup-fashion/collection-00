// SPDX-License-Identifier: MIT
//
// This software is developed by DRAUP, Inc. "DRAUP" is a trademark of DRAUP, Inc.
// in the United States and other countries. Nothing herein grants you any rights in
// or to DRAUP, Inc.'s trade names or trademarks, all of which are expressly
// reserved to DRAUP, Inc.
//
//
//
//                            DRAUP COLLECTION 00
//
//                          DRAUP X NICOLAS SASSOON
//
//                              SEEN ON SCREEN
//
//
//                                                           .,,
//                                                           ;░░▒▒
//                                                           ;░φφ░╚╠
//                                                       .░φ░░░░Γ╙╙
//                                                       '░░░░
//                                                           ░░░░
//                                                           ¡░░░░
//                                                           ¡░░░░
//                                                           ¡░░░¡░
//                                                           :░░▒░!-
//                                                           ¡░¡░▒░│-
//                                                       .│''░▒░┐'░
//                                                       ;''¡░╠▒░.'░
//                                                   .,,;'''¡░╠╠░░. ┌
//                                               .░░░░░░┐..¡¡░╠╠▒░┐ '.
//                                               .░│¡░░░░░░░¡░░░▒╠▒░░. '~
//                                               ;│.¡░░░░░░░░░░░░▒╠╠░░' .
//                                           ;░┌¡░░░░░░░░░░░░▒╠╠╠░░'.░⌐
//                                             ;░.¡░░φ▒▒▒▒▒░░░░▒▒╠╬▒░░\░░
//                                           ;░┐¡░φ╠╠╬╬╠╠▒▒▒▒▒╠╠╬╠▒░░░░
//                                       .░░.░φ▒╠╬╬╬╣╣╣╬╬╠╠╠╠╬╬▒░░░░
//                                       .░░│░░▒╠╠╠╠╬╬╬▓██▓▓╬╬╬╬▒░░░░
//                                       ░░░░φ▒╩╚╩╚╚Γ└''└│╙╙╚╩╩╩╚╙Γ"
//                                   .\¡░φ▒░░░░░░░       ''''''
//                                   ¡¡░▒░░░│││¡└
//                                   .¡░░░░░│'''¡'
//                               .░░░░░░░░┐''│¡~
//                       .,░φ░░░░░░░░░░░░░│..'!░
//                   .░░░░░░░░░░░░░░░░░░░░░░┐. !-
//                   ;░░φ▒▒▒▒░░░░░░░░░░░░░░░░░░░┐.'-
//               .░░φ▒▒▒▒░░░░░░▒▒▒▒╠╠╠▒▒▒▒▒▒▒φ░░░¡░.
//               .░░▒╠╠▒░░░░░░░░▒╠╠╩╩╩╩╩╩╬╬╣╣╣▓╣╬▒▒φ░░;
//               .¡░▒╠╠▒░░░░░░░░░░Γ░└'''''''""╙╙╩╬╬╬╬╣╣╬▒φ░»,
//               :░φ╠╬▒▒░░░░░░░░░░             '''!╙╚╩╠╠╠╠╠╠╠▒φφφ░,
//               :░▒╬╬▒▒░░░░░░░░'                   '!░░░╠╠╠╠╠╠╠▒▒▒░░░.
//               :░╠╬╬▒▒░░░░░░░'                     .░░░▒▒╠╠╠╠▒▒▒▒▒▒░░░.
//               '░╚╬╬▒▒░░░░░░                     .≥░░░▒▒▒▒▒▒▒▒▒▒▒▒▒░░░┐-
//               !░╠╬▒▒░░░░░                  ,;φ░░░░▒▒▒▒▒▒▒▒▒▒▒╠╠▒▒▒░░░┌.
//               ^░╠╬╠▒▒░░░               ,φ░░░░░░▒▒▒▒▒▒▒▒▒▒▒▒▒╠╠╠▒▒▒░░░│¡
//               !╚╬╬▒▒░▒░            »░░░░░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒╠╠╠╠╠▒▒▒░░░░░
//               '░╠╬▒▒▒▒░         ,φ░░░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒╠╠╠╠╠╠╠╠╠▒▒░░░░░
//                   '╚╠▒▒▒▒░       ;░░░▒▒▒╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠▒▒░░░░░
//                   ░╠▒▒▒▒▒░  .,φφ▒▒▒╠╠╠╬╬╬╬╬╬╬╬╬╬╬╬╠╠╠╬╬╬╬╬╬╬╬╬╬╠╠▒▒░░░░
//                   ]╠▒▒▒▒▒▒▒╠╠╠╠╠╠╠╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╠▒▒░░░'
//                   ]╠▒▒▒▒▒▒▒╠╠╠╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╠▒▒▒░'
//                   !╠╠▒▒▒▒▒▒╠╠╠╠╬╬╬╬╬╬╬╬╬╬╬╬╬╬╣▓▓▓▓▓▓▓▓▓▓▓▓╬╬╬╬╬╬╠╠╩░'
//                   '╙╬╬▒▒▒▒▒╠╠╠╠╠╠╬╬╬╬╬╬╬╬╬╬╬╬╣▓▓▓▓▓▓▓▓▓▓▓▓▓▓╬╬╬╬╩Γ"
//                   '!╚╣╬╬╠╠╠╠╠╠╠╬╬╬╬╬╬╬╬╬╬╬╬╬╬╣▓▓▓▓▓▓▓▓▓▓▓▓╬╬╩╙░'
//                       '░╚╣▓▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╣▓▓▓▓▀╩╩╙╙░└''
//                       '!╙╩╣▓▓╣╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╩╙░"''
//                           '!╙╚╬▓▓▓▓▓╬╬╬╬╬╬╬╬╬╬╩╙Γ"'
//
//
//
pragma solidity ~0.8.18;
import {Ownable} from "openzeppelin-contracts/contracts/access/Ownable.sol";
import {ECDSA} from "openzeppelin-contracts/contracts/utils/cryptography/ECDSA.sol";
import {ERC721A} from "erc721a/contracts/ERC721A.sol";
import {DefaultOperatorFilterer} from "operator-filter-registry/src/DefaultOperatorFilterer.sol";
import {BitSplit} from "./BitSplit.sol";

// define constants for the item types
uint256 constant COAT_ITEM_TYPE = 0;
uint256 constant DRESS_ITEM_TYPE = 1;
uint256 constant PANTS_ITEM_TYPE = 2;
uint256 constant TOP_ITEM_TYPE = 3;
uint256 constant HAT_ITEM_TYPE = 4;

// define constants for checking mint access permissions
uint constant SUCCESS_MINT_ALLOWED = 0;
uint constant ERR_SENDER_NOT_ALLOWED = 1;
uint8 constant ERR_ITEM_QUANTITY_ZERO = 2;
uint8 constant ERR_ITEM_QUANTITY_TOO_HIGH = 3;
uint8 constant ERR_INSUFFICIENT_FUNDS = 4;
uint8 constant ERR_INSUFFICIENT_ITEM_SUPPLY = 5;
uint8 constant ERR_CANNOT_MINT_ITEM_TYPE = 6;

// define constants for mint process
uint constant MINT_NOT_STARTED = 0;
uint constant MINT_IN_PROGRESS = 1;
uint constant MINT_FINISHED = 2;

contract DRAUPCollection00 is ERC721A, Ownable, DefaultOperatorFilterer {
    using ECDSA for bytes32;
    using BitSplit for uint256;

    uint[5] private maxSupplies;
    uint[5] private mintPrices;
    uint public mintingStatus;
    address public signer;
    string public baseTokenURI;

    mapping(uint256 => uint256) private _tokenItemTypes;

    mapping(uint256 => bytes32) private _tokenSeeds;

    constructor(uint256[5] memory setSupply, uint256[5] memory setMintPrices, string memory initialBaseURI) ERC721A("DRAUP COLLECTION 00", "DRAUP:00") {
        maxSupplies = setSupply;
        mintPrices = setMintPrices;
        baseTokenURI = initialBaseURI;
    }

    // Token Info

    error MintValidationFailure(uint errorCode);

    function getMaxSupply() public view returns (uint256) {
        return maxSupplies[0] + maxSupplies[1] + maxSupplies[2] + maxSupplies[3] + maxSupplies[4];
    }

    function getItemMaxSupply(uint256 itemType) public view returns (uint256) {
        return maxSupplies[itemType];
    }

    function getItemSupply(uint256 itemType) public view returns (uint256) {
        return maxSupplies[itemType];
    }

    function tokenInfo(uint256 tokenId) public view returns (uint256 itemType, bytes32 seed) {
        itemType = _tokenItemTypes[tokenId];
        seed = _tokenSeeds[tokenId];
    }

    function tokenInfos(uint256 start, uint256 end) public view returns (uint256[] memory itemTypes, bytes32[] memory seeds) {
        if (end == 0) {
            end = _nextTokenId();
        }
        require(start < end, "start must be less than end");
        itemTypes = new uint256[](end-start);
        seeds = new bytes32[](end-start);
        for (uint256 i = start; i < end; i++) {
            itemTypes[i-start] = _tokenItemTypes[i];
            seeds[i-start] = _tokenSeeds[i];
        }
    }

    // Minting

    error MintingNotActive();

    function mintingIsActive() public view returns (bool) {
        return mintingStatus == MINT_IN_PROGRESS;
    }

    modifier onlyDuringMinting() {
        if (!mintingIsActive()) {
            revert MintingNotActive();
        }
        _;
    }

    // hero pieces minted by DRAUP using short form generative techniques
    function mintCoats(address to, bytes32[] calldata seeds) public onlyOwner {
        uint256 startTokenId = _nextTokenId();
        uint256 itemType = COAT_ITEM_TYPE;
        if (seeds.length > maxSupplies[itemType]) {
            revert MintValidationFailure(ERR_INSUFFICIENT_ITEM_SUPPLY);
        }
        maxSupplies[itemType] -= seeds.length;
        for (uint i=0; i<seeds.length; i++) {
            _mint(to, 1);
            // item type is 0
            _tokenSeeds[startTokenId+i] = seeds[i];
        }
    }

    function mintingIsAllowed(uint itemType, uint quantity) public view returns (uint) {
        if (itemType == 0 || itemType > 4) {
            return ERR_CANNOT_MINT_ITEM_TYPE;
        }
        if (quantity == 0) {
            return ERR_ITEM_QUANTITY_ZERO;
        }
        if (quantity > 4) {
            return ERR_ITEM_QUANTITY_TOO_HIGH;
        }
        if (maxSupplies[itemType] < quantity) {
            return ERR_INSUFFICIENT_ITEM_SUPPLY;
        }
        // TODO add check for valid digital signature from allow list
        return SUCCESS_MINT_ALLOWED;
    }

    function mintCostForItems(uint itemType, uint quantity) public view returns (uint totalCost) {
        totalCost = mintPrices[itemType] * quantity;
    }

    // main collection pieces minted by public using long form generative techniques
    function mintItems(address to, uint itemType, uint quantity) public payable onlyDuringMinting {
        uint minterStatus = mintingIsAllowed(itemType, quantity);
        if (minterStatus != SUCCESS_MINT_ALLOWED) {
            revert MintValidationFailure(minterStatus);
        }
        uint totalCost = mintCostForItems(itemType, quantity);
        if (msg.value < totalCost) {
            revert MintValidationFailure(ERR_INSUFFICIENT_FUNDS);
        }
        // mint the tokens
        maxSupplies[itemType] -= quantity;
        uint batchStartTokenId = _nextTokenId();
        uint rand = block.prevrandao;
        for (uint i=0; i<quantity; i++) {
            if (quantity > 1) {
                uint[4] memory rquarters = rand.splitQuarter();
                if (quantity == 2) {
                    if (i == 0) {
                        rand = rquarters[0] | rquarters[1];
                    } else {
                        rand = rquarters[2] | rquarters[3];
                    }
                } else {
                    // NB: when batch size is 3 we drop the randomness contribution from the last quarter of randao
                    rand = rquarters[i];
                }
            }
            bytes32 seed = keccak256(abi.encodePacked(batchStartTokenId+i, rand, blockhash(block.number - 1), msg.sender));
            _tokenItemTypes[batchStartTokenId+i] = itemType;
            _tokenSeeds[batchStartTokenId+i] = seed;
        }
        _mint(to, quantity);
    }

    // Transfers, secondary trading, and on-chain royalty enforcement integration

    function setApprovalForAll(address operator, bool approved) public override onlyAllowedOperatorApproval(operator) {
        super.setApprovalForAll(operator, approved);
    }

    function approve(address operator, uint256 tokenId) public override payable onlyAllowedOperatorApproval(operator) {
        super.approve(operator, tokenId);
    }

    function transferFrom(address from, address to, uint256 tokenId) public override payable onlyAllowedOperator(from) {
        super.transferFrom(from, to, tokenId);
    }

    function safeTransferFrom(address from, address to, uint256 tokenId) public override payable onlyAllowedOperator(from) {
        super.safeTransferFrom(from, to, tokenId);
    }

    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data)
        public
        override
        payable
        onlyAllowedOperator(from)
    {
        super.safeTransferFrom(from, to, tokenId, data);
    }

    // Admin actions

    error AdminActionFailure();

    function startMinting() public onlyOwner {
        if (mintingStatus == MINT_FINISHED) {
            revert AdminActionFailure();
        }
        mintingStatus = MINT_IN_PROGRESS;
    }

    function pauseMinting() public onlyOwner {
        if (mintingStatus == MINT_FINISHED) {
            revert AdminActionFailure();
        }
        mintingStatus = MINT_NOT_STARTED;
    }

    function finishMinting() public onlyOwner {
        mintingStatus = MINT_FINISHED;
    }

    function setBaseURI(string memory newBaseURI) public onlyOwner {
        baseTokenURI = newBaseURI;
    }



}